## Problem 011: Largest Product in a Grid
*In the $20\times 20$ grid below, four numbers along a diagonal line have been marked in red.*
<small>08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08<br />
49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00<br />  
81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65 <br /> 
52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91  <br />
22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80  <br />
24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50  <br />
32 98 81 28 64 23 67 10 <b style="color: red">26</b> 38 40 67 59 54 70 66 18 38 64 70  <br />
67 26 20 68 02 62 12 20 95 <b style="color: red">63</b> 94 39 63 08 40 91 66 49 94 21  <br />
24 55 58 05 66 73 99 26 97 17 <b style="color: red">78</b> 78 96 83 14 88 34 89 63 72  <br />
21 36 23 09 75 00 76 44 20 45 35 <b style="color: red">14</b> 00 61 33 97 34 31 33 95  <br />
78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92  <br />
16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57  <br />
86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58  <br />
19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40  <br />
04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66  <br />
88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69  <br />
04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36  <br />
20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16  <br />
20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54  <br />
01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48</small>
*The product of these numbers is $26\times 63\times 78 \times 14=1788696$. What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the $20\times 20$ grid?*

We solve this problem via brute force.
```js
function solution(arr) {
    let dimension = arr.length;
    let greatestProduct = 0;

    // Read horizontally.
    for (let i = 0; i < dimension - 3; ++i) {
        for (let j = 0; j < dimension; ++j) {
            let product = arr[i][j] * arr[i][j + 1] * arr[i][j + 2] * arr[i][j + 3];
            if (product > greatestProduct) {
                greatestProduct = product;
            }
        }
    }

    // Read vertically.
    for (let i = 0; i < dimension - 3; ++i) {
        for (let j = 0; j < dimension; ++j) {
            let product = arr[i][j] * arr[i + 1][j] * arr[i + 2][j] * arr[i + 3][j];
            if (product > greatestProduct) {
                greatestProduct = product;
            }
        }
    }

    // Read diagonally (\)
    for (let i = 0; i < dimension - 3; ++i) {
        for (let j = 0; j < dimension - 3; ++j) {
            let product = arr[i][j] * arr[i + 1][j + 1] * arr[i + 2][j + 2] * arr[i + 3][j + 3];
            if (product > greatestProduct) {
                greatestProduct = product;
            }
        }
    }

    // Read diagonally (/)
    for (let i = 0; i < dimension - 3; ++i) {
        for (let j = dimension - 1; j >= 3; --j) {
            let product = arr[i][j] * arr[i + 1][j - 1] * arr[i + 2][j - 2] * arr[i + 3][j - 3];
            if (product > greatestProduct) {
                greatestProduct = product;
            }
        }
    }

    return greatestProduct;
}
```
**Solved 24th July 2025.**

## Problem 012: Highly Divisible Triangular Number
*The sequence of triangle numbers is generated by adding the natural numbers. So the $7^{\text{th}}$ triangle number would be $1+2+3+4+5+6+7=28$. Let us list the factors of the first seven triangle numbers:*
$$
\begin{align}
1&: 1 \\
3&: 1,3 \\
6&:1,2,3,6 \\
10&:1,2,5,10 \\
15&:1,3,5,15 \\
21&:1,3,7,21 \\
28&:1,2,4,7,14,28
\end{align}
$$
*The first ten terms would be 1, 3, 6, 10, 15, 21, 28, 36, 45, 55. We can see that 28 is the first triangle number to have over five divisors. What is the value of the first triangle number to have over five hundred divisors?*

Consider the triangle number $36$ as an example.
$$
36=2^{2}\times 3^{2},\text{ factors are }1,2,3,4,6,9,12,18,36
$$
Each of the factors is a unique term based on the expansion of
$$
(2^{0}+2^{1}+2^{2})(3^{0}+3^{1}+3^{2}).
$$
This expansion will yield $9$ terms. In particular, for any composite number, the number of factors will be based on a similar expansion. Hence, for a composite number
$$
n=p_{1}^{a_{1}}\times p_{2}^{a_{2}}+\dots+p_{n}^{a_{n}},
$$
then the number of factors will be equal to
$$
\sum_{n}a_{n}.
$$
The program generates the $n$th triangle number with $\frac{1}{2}n(n+1)$, and computes the number of factors based on this property.
```js
function solution(n) {
	import { PrimeSieve } from "./PrimeSieve";
	
    let sieve = new PrimeSieve();
    let triangle = 1, numFactors = 1, exponent = 0;
    let primePowers = [];


    for (let i = 1; true; ++i) {
        primePowers = [];
        triangle = (i * (i + 1)) / 2;

        if (Math.sqrt(triangle) >= sieve.primes[sieve.primes.length - 1]) {
            sieve.extend();
        }
  
        sieve.primes.forEach((prime) => function() {
            exponent = 0;

            while (triangle % prime == 0) {
                exponent++;
                triangle /= prime;
            }

            if (exponent) {
                primePowers.push(exponent);
            }
        }());

        triangle = (i * (i + 1)) / 2;

        primePowers.forEach((power) => numFactors *= (power + 1));
  
        if (numFactors >= n) {
            return triangle;
        } else {
            numFactors = 1;
        }
    }
}
```
**Solved 24th July 2025.**
**Sources**:
https://math.stackexchange.com/questions/2782625/how-to-get-all-the-factors-of-a-number-using-its-prime-factorization (Number of factors based on prime factorization)

## Problem 013: Large Sum
*Work out the first ten digits of the sum of the following one-hundred $50$-digit numbers.*

To solve this in C++, a class for large numbers (represented as a string will be defined). This class will be able to simulate arithmetic addition by the digit. The solution below will be written in C++ instead; both Python and JavaScript have built-in functionality to represent large integers.

```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <fstream>
  
using namespace std;

class LargeNumber {
public:
    LargeNumber(string n) {
        number = n;
    }

    string number;
};

LargeNumber operator+ (const LargeNumber &n1, const LargeNumber &n2) {
    string sumNumber = "";
    
    int carry = 0;
    string shorterNumber, longerNumber;
    size_t longerLength;

    if (n1.number.length() < n2.number.length()) {
        longerNumber = n2.number;
        longerLength = n2.number.length();
        shorterNumber = n1.number;
    } else {
        longerNumber = n1.number;
        longerLength = n1.number.length();
        shorterNumber = n2.number;  
    }

    reverse(shorterNumber.begin(), shorterNumber.end());
    reverse(longerNumber.begin(), longerNumber.end());

    while(shorterNumber.length() < longerLength) {
        shorterNumber.push_back('0');
    }
  
    for(size_t i = 0; i < longerLength; i++) {
        int digit = (shorterNumber.at(i) - 48) + (longerNumber.at(i) - 48) + carry;

        if (digit > 9) {
            carry = 1;
            digit -= 10;
        } else {
            carry = 0;
        }

        sumNumber.push_back(digit + '0');
    }

    if (carry) {
        sumNumber.push_back(carry + '0');
    }

    reverse(sumNumber.begin(), sumNumber.end());
    return LargeNumber(sumNumber);
}

string solution() {
    LargeNumber sum("");

    fstream file;
    string line;

    file.open("../013.txt");
    
    if (file.is_open()) {
        while (getline(file, line)) {
            sum = sum + LargeNumber(line);
        }
    }

    return sum.number.substr(0, 10);
}
```
**Note:** this solution uses char manipulations. 
**Solved 25th July 2025.**

## Problem 014: Longest Collatz Sequence
*The following iterative sequence is defined for the set of positive integers:*
$$
\begin{align}
n&\to \frac{n}{2}\text{ (}n\text{ is even)} \\
n&\to 3n+1\text{ (}n\text{ is odd)}
\end{align}
$$
*Using the rule above and starting with $13$, we generate the following sequence:*
$$
13\to 40\to 20\to 10\to 5\to 16\to 8\to 4\to 2\to 1
$$
*It can be seen that this sequence (starting at $13$ and finishing at $1$) contains $10$ terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at $1$. Which starting number, under one million, produces the longest chain? **NOTE:** Once the chain starts the terms are allowed to go above one million.*

Rather than brute-forcing every single number under $1000000$, we can start checking from $\frac{1000000}{2}=500000$. This is because the length of the Collatz sequence of any number $n$ is shorter than the sequence of $2n$ (by $1$). 

```js
function solution(n) {
    let longest = 0, terms = 1, longestTerms = 1, k;
    for (let i = Math.round(n / 2); i < n; i++) {
        terms = 1, k = i;

        while (k != 1) {
            terms++;
            if (k % 2) {
                k = 3 * k + 1;
            } else {
                k = k / 2;
            }
        }

        if (terms > longestTerms) {
            longestTerms = terms;
            longest = i;
        }
    }

    return longest;
}
```
**Solved 26th July 2025.**

## Problem 015: Lattice Paths
*Starting in the top left corner of a $2\times 2$ grid, and only being able to move to the right and down, there are exactly $6$ routes to the bottom right corner. How many such routes are there through a $20\times 20$ grid?*

This is more of a combinatorics problem than a programming one. First note the case for a $2\times 2$ grid. We notice that to reach the bottom-right corner, $4$ steps have to be taken. At each point in the grid, the path can only go either right or down. The path must go right $2$ times, and go down $2$ times. For this case, the number of routes possible will be
$$
\frac{4!}{2!\times 2!}\equiv \binom{4}{2}=6.
$$
It is also to be noted that
$$
\binom{n}{r}=\frac{n!}{r!(n-r)!}=1\times \frac{n-r+1}{1}\times \frac{n-r+2}{2}\times\dots
$$
Hence, without the use of factorials, we can obtain a solution with repeated multiplications. For an $n\times n$ grid, there are $_{2n}C_{n}$ different possible routes.

```js
function solution(n) {
    let sum = 1n;

    for (let i = 1; i <= n; i++){
        sum = sum * (BigInt(n) + BigInt(i)) / BigInt(i);
    }

    return sum;
}
```
**Solved 26th July 2025.**
**Sources:**
https://www.geeksforgeeks.org/dsa/program-calculate-value-ncr/#expected-approach-by-using-binomial-coefficient-formula (Implementing $_{n}C_{r}$)

## Problem 016: Power Digit Sum
*$2^{15}=32768$ and the sum of its digits is $3+2+7+6+8=26$. What is the sum of the digits of the number $2^{1000}$?*

Similar to Problem 013, we extend the LargeNumber class in C++ to include multiplication, based off the existing addition operation. Its functionality is based off arithmetic multiplication. For instance,
$$
2375\times 32=(2375\times 30)+(2375\times 2).
$$

```cpp
LargeNumber operator* (const LargeNumber &n1, const LargeNumber &n2) {
    LargeNumber product("");

    int carry = 0;
    string shorterNumber, longerNumber;
    size_t shorterLength, longerLength;

    if (n1.number.length() < n2.number.length()) {
        longerNumber = n2.number;
        longerLength = n2.number.length();
        shorterNumber = n1.number;
        shorterLength = n1.number.length();
    } else {
        longerNumber = n1.number;
        longerLength = n1.number.length();
        shorterNumber = n2.number;
        shorterLength = n2.number.length();
    }

    reverse(shorterNumber.begin(), shorterNumber.end());
    reverse(longerNumber.begin(), longerNumber.end());

    for(size_t i = 0; i < shorterLength; i++) {
        LargeNumber innerProduct("");
        int currentDigit = shorterNumber.at(i) - '0';
        carry = 0;
  

        for (size_t j = 0; j < longerLength; j++) {
            int digit = currentDigit * (longerNumber.at(j) - '0') + carry;
            carry = digit / 10;
            digit = digit % 10;

            innerProduct.number.push_back(digit + '0');
        }

        if (carry) {
            innerProduct.number.push_back(carry + '0');
        }

        reverse(innerProduct.number.begin(), innerProduct.number.end());

        for (size_t j = 0; j < i; j++) {
            innerProduct.number.push_back('0');
        }

        product = product + innerProduct;

    }
    
    return product;
}

  

int solution() {
    LargeNumber twoToFifty(to_string(
        static_cast<unsigned long long>(pow(2, 50))));
    LargeNumber twoToAThousand(to_string(
        static_cast<unsigned long long>(pow(2, 50))));

    for (int i = 0; i < 19; i++) {
        twoToAThousand = twoToAThousand * twoToFifty;
    }

    int digitSum = 0;
    for (char digit : twoToAThousand.number) {
        digitSum += (digit - '0');
    }

    return digitSum;
}
```
**Solved 28th July 2025.**